import{r as c}from"./index-ClcD9ViR.js";import{q as j,a1 as z,l as H,N as P}from"./factory-Nur_zO5a.js";const W=(r,e)=>{const t=getComputedStyle(r);return["auto","overlay","scroll"].includes(t.overflow)?!0:e?["auto","overlay","scroll"].includes(t.overflowY):["auto","overlay","scroll"].includes(t.overflowX)},C=({behavior:r,position:e,reverse:t,root:a,vertical:v})=>{let m;const p=P(a)&&W(a,v)?a:document.body;v?m={behavior:r,top:e??(t?p.scrollHeight:0)}:m={behavior:r,left:e??(t?p.scrollWidth:0)},p===document.body?window.scrollTo(m):p.scrollTo(m)},A=(r,e)=>{const t=P(r)&&W(r,e)?r:document.body;return e?t.scrollHeight-t.scrollTop:t.scrollWidth-t.scrollLeft},J=({behavior:r,disabled:e,indexRef:t,initialLoad:a=!1,isDisabled:v=!1,isReverse:m=!1,orientation:p="vertical",resetRef:q,reverse:o,rootMargin:T,rootRef:s,startIndex:L=a?0:1,threshold:k,onLoad:N}={})=>{e??(e=v),o??(o=m);const w=c.useRef(null),b=c.useRef(L),y=c.useRef(!1),S=c.useRef(void 0),h=c.useRef(!1),B=c.useRef(0),[U,E]=c.useState(!1),g=j(N),f=p==="vertical",O=c.useMemo(()=>({root:s==null?void 0:s.current,rootMargin:T,threshold:k}),[T,s,k]),X=c.useCallback((l=1,n=!0)=>{if(b.current=l,E(!1),n){const i=s==null?void 0:s.current;C({behavior:r,reverse:o,root:i,vertical:f})}e||setTimeout(()=>{const i=S.current,u=w.current;u&&(i==null||i.observe(u))})},[e,o,s,f,r]),x=c.useCallback(()=>{const l=S.current,n=w.current;n&&(l==null||l.unobserve(n)),E(!0)},[]),I=c.useCallback(()=>new IntersectionObserver(async([n])=>{if(!(n!=null&&n.isIntersecting)||y.current)return;const i={entry:n,finish:x,index:b.current};y.current=!0;const u=s==null?void 0:s.current;if(u&&(u.ariaBusy="true"),o&&(B.current=A(u,f)),await g(i),o){const d=B.current;C({position:d,root:u,vertical:f})}b.current+=1,y.current=!1,u&&(u.ariaBusy="false")},O),[x,g,O,s,o,f]);return c.useEffect(()=>{(async()=>{const n=w.current,i=h.current,u=b.current,d=s==null?void 0:s.current;if(a&&!i&&(y.current=!0,d&&(d.ariaBusy="true"),await g({finish:x,index:u}),b.current+=1,y.current=!1,d&&(d.ariaBusy="false")),e)return;S.current=I();const F=S.current;if(o&&!i){const Y=s==null?void 0:s.current;C({reverse:o,root:Y,vertical:f}),h.current=!0}return setTimeout(()=>{n&&F.observe(n)}),()=>{n&&F.unobserve(n)}})()},[I,a,e,o,f,x,g,s]),z(()=>h.current=!1),H(q,X),H(t,l=>b.current=l),{ref:w,finish:U}};export{J as u};
